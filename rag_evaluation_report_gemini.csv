user_input,retrieved_contexts,response,reference,faithfulness,answer_relevancy,answer_correctness
การบันทึก Log มีกี่ระดับ และแต่ละระดับควรบันทึกอะไรบ้าง,"[""**มาตรฐานการบันทึก Log:** ให้บันทึก Log อย่างครอบคลุมเพื่อการติดตามและแก้ไขข้อบกพร่อง ใช้ระดับ `Info` สำหรับพารามิเตอร์และขั้นตอนการทำงาน (เริ่มต้น, สำเร็จ/สิ้นสุด) และใช้ระดับ `Error` สำหรับ Exception ทุกฟังก์ชันต้องมีจุดบันทึก Log 'Start', 'End' และ 'Error' สำหรับ handler ให้ใช้ชื่อคลาสหรือ handler ในข้อความ Log และให้บันทึกพารามิเตอร์ของ SQL ก่อนการประมวลผล""]",มาตรฐานการบันทึก Log กำหนดให้ใช้ระดับ `Info` เพื่อบันทึกข้อมูลเกี่ยวกับพารามิเตอร์และขั้นตอนการทำงานต่างๆ เช่น จุดเริ่มต้น (Start) และจุดสิ้นสุด (End) ของฟังก์ชัน นอกจากนี้ยังกำหนดให้ใช้ระดับ `Error` เพื่อบันทึก Exception ที่เกิดขึ้น เพื่อให้สามารถติดตามและแก้ไขข้อบกพร่องได้อย่างมีประสิทธิภาพ,"มี 2 ระดับหลักๆ คือ Info และ Error. ระดับ Info ใช้สำหรับบันทึกพารามิเตอร์และรายละเอียดของกระบวนการ , ส่วนระดับ Error ใช้สำหรับบันทึกข้อยกเว้น (Exception) เท่านั้น.",,,
ในหนึ่งฟังก์ชันควรมี logger อย่างน้อยกี่ที่และที่ไหนบ้าง,"[""**มาตรฐานการบันทึก Log:** ให้บันทึก Log อย่างครอบคลุมเพื่อการติดตามและแก้ไขข้อบกพร่อง ใช้ระดับ `Info` สำหรับพารามิเตอร์และขั้นตอนการทำงาน (เริ่มต้น, สำเร็จ/สิ้นสุด) และใช้ระดับ `Error` สำหรับ Exception ทุกฟังก์ชันต้องมีจุดบันทึก Log 'Start', 'End' และ 'Error' สำหรับ handler ให้ใช้ชื่อคลาสหรือ handler ในข้อความ Log และให้บันทึกพารามิเตอร์ของ SQL ก่อนการประมวลผล""]","ตามมาตรฐานการบันทึก Log (BE-1) ทุกฟังก์ชันควรมีจุดบันทึก Log อย่างน้อย 3 จุด ได้แก่ จุดเริ่มต้น ('Start'), จุดสิ้นสุด ('End') และจุดที่เกิดข้อผิดพลาด ('Error') เพื่อให้สามารถติดตามการทำงานของฟังก์ชันและแก้ไขข้อผิดพลาดที่อาจเกิดขึ้นได้อย่างมีประสิทธิภาพ การบันทึก Log ในระดับ `Info` ควรใช้สำหรับพารามิเตอร์และขั้นตอนการทำงาน (เริ่มต้น, สำเร็จ/สิ้นสุด) และระดับ `Error` สำหรับ Exception","ควรมี logger อย่างน้อย 3 ที่. คือ Logger Start ที่ส่วนแรกของ try block, Logger End ก่อนบรรทัด return, และ Logger Error ภายใน catch block.",,,
_context.QueryAsync และ _context.ExecuteAsync แตกต่างกันอย่างไร,[],กฎที่ให้มาเน้นที่แนวทางการเขียนโค้ดที่ดี เช่น การใช้ `AddRangeAsync` สำหรับการเพิ่มข้อมูลจำนวนมาก การใช้ `try-catch` เพื่อจัดการข้อผิดพลาด การบันทึก Log อย่างละเอียด และการตรวจสอบความถูกต้องของข้อมูลที่ส่งไปยัง Backend อย่างไรก็ตาม ไม่มีกฎใดที่อธิบายความแตกต่างระหว่าง `_context.QueryAsync` และ `_context.ExecuteAsync` โดยตรง ดังนั้นจึงไม่มีกฎใดที่เกี่ยวข้องกับคำถามนี้โดยตรง,"`_context.QueryAsync` ใช้สำหรับการอ่านข้อมูล (SELECT) และคืนค่าเป็น `IEnumerable<T>` หรือ `List<T>`. ส่วน `_context.ExecuteAsync` ใช้สำหรับการเปลี่ยนแปลงข้อมูล (INSERT, UPDATE, DELETE) และคืนค่าเป็น `int` ซึ่งคือจำนวนแถวที่ถูกแก้ไข.",,,
"การตั้งชื่อ Class, Method, Property และตัวแปรภายใน Method ควรใช้รูปแบบใด","['**รูปแบบการตั้งชื่อ:** ให้ยึดตามมาตรฐานการตั้งชื่อของ C# โดยใช้ PascalCase สำหรับคลาส, เมธอด, property และ field (เช่น `LeaveRequest`, `SaveData()`, `EmployeeId`) และใช้ camelCase สำหรับตัวแปรภายในเมธอด (เช่น `leaveType`, `totalCount`)']","ตามมาตรฐานการเขียนโค้ด C# ที่กำหนดไว้, Class, Method, และ Property ควรตั้งชื่อโดยใช้ PascalCase (เช่น `LeaveRequest`, `SaveData()`, `EmployeeId`) ในขณะที่ตัวแปรภายใน Method ควรตั้งชื่อโดยใช้ camelCase (เช่น `leaveType`, `totalCount`) การปฏิบัติตามรูปแบบเหล่านี้จะช่วยให้โค้ดมีความสอดคล้องและอ่านง่ายขึ้น","Class, Property, และ Method ใช้รูปแบบ PascalCase. ส่วนตัวแปรภายใน method ใช้รูปแบบ camelCase.",,,
การใช้ AddRangeAsync มีข้อจำกัดอะไร,['**ใช้ AddRange สำหรับการเพิ่มข้อมูลจำนวนมาก:** เมื่อต้องการเพิ่มข้อมูลหลายรายการที่ตรงกับ Entity ให้วนลูปข้อมูลต้นทางเพื่อสร้างอ็อบเจกต์ Entity ใหม่ แล้วเพิ่มลงใน `List<>` จากนั้นใช้ `_context.Set<>().AddRangeAsync()` เพื่อเพิ่มข้อมูลทั้งหมดลงในฐานข้อมูลอย่างมีประสิทธิภาพในครั้งเดียว วิธีนี้ใช้สำหรับการเพิ่มข้อมูลใหม่เท่านั้น ไม่สามารถใช้กับการอัปเดตได้'],"ตามมาตรฐาน BE-2, `AddRangeAsync` เหมาะสำหรับการเพิ่มข้อมูลจำนวนมากโดยการสร้างอ็อบเจกต์ Entity ใหม่จากข้อมูลต้นทาง แล้วเพิ่มลงใน `List<>` จากนั้นใช้ `_context.Set<>().AddRangeAsync()` เพื่อเพิ่มข้อมูลทั้งหมดลงในฐานข้อมูลอย่างมีประสิทธิภาพในครั้งเดียว ข้อจำกัดที่สำคัญคือ วิธีนี้ใช้สำหรับการเพิ่มข้อมูลใหม่เท่านั้น และไม่สามารถใช้กับการอัปเดตข้อมูลที่มีอยู่ได้",`AddRangeAsync` สามารถใช้ได้แค่กรณีเพิ่มข้อมูลเท่านั้น ไม่สามารถใช้สำหรับ update ข้อมูลได้.,,,
เพราะเหตุใดการคำนวณทั้งหมดจึงควรทำที่ Backend และมีวิธีการที่ถูกต้องอย่างไร,"['**การคำนวณต้องทำที่ฝั่ง Backend:** หลีกเลี่ยงการคำนวณที่ฝั่ง Frontend โดยให้ Client ส่งแค่ข้อมูลระบุตัวตน (เช่น รายการ ID) มายัง Backend จากนั้น Backend จะมีหน้าที่ดึงข้อมูลจริงจากฐานข้อมูลมาทำการคำนวณที่จำเป็นทั้งหมด แล้วจึงบันทึกผลลัพธ์ ซึ่งจะช่วยป้องกันการแก้ไขค่าที่คำนวณแล้วจากฝั่ง Client', '**ส่งการตรวจสอบที่ซับซ้อนไปให้ Backend:** ห้าม implement business logic หรือการคำนวณที่ละเอียดอ่อนไว้ที่ Frontend แต่ให้ส่งข้อมูลดิบจากผู้ใช้ไปให้ Backend เพื่อทำการตรวจสอบและประมวลผลทั้งหมด Frontend ควรทำหน้าที่เพียงแสดงผลลัพธ์โดยยึดว่า Backend เป็นแหล่งข้อมูลที่ถูกต้องเพียงแห่งเดียว']",การคำนวณทั้งหมดควรทำที่ Backend เพื่อป้องกันการแก้ไขค่าที่คำนวณแล้วจากฝั่ง Client และรักษาความถูกต้องของข้อมูล โดย Client ส่งเพียงข้อมูลระบุตัวตน (เช่น รายการ ID) มายัง Backend จากนั้น Backend จะมีหน้าที่ดึงข้อมูลจริงจากฐานข้อมูลมาทำการคำนวณที่จำเป็นทั้งหมด แล้วจึงบันทึกผลลัพธ์ นอกจากนี้ การตรวจสอบที่ซับซ้อนหรือ business logic ที่ละเอียดอ่อนก็ควรทำที่ Backend เช่นกัน โดย Frontend ทำหน้าที่เพียงแสดงผลลัพธ์โดยยึดว่า Backend เป็นแหล่งข้อมูลที่ถูกต้องเพียงแห่งเดียว,ควรทำที่ Backend เพื่อหลีกเลี่ยงความเสี่ยงที่ผู้ใช้อาจแก้ไขค่าที่ส่งมา. วิธีที่ถูกต้องคือให้ Frontend ส่งแค่ ID ของรายการไปให้ Backend เพื่อดึงข้อมูลจริงจากฐานข้อมูลมาคำนวณและบันทึกผล.,,,
อธิบายขั้นตอนการบันทึก Log ในหนึ่งฟังก์ชัน ตั้งแต่เริ่มต้นจนสิ้นสุดกระบวนการ รวมถึงกรณีที่เกิดข้อผิดพลาด,"[""**มาตรฐานการบันทึก Log:** ให้บันทึก Log อย่างครอบคลุมเพื่อการติดตามและแก้ไขข้อบกพร่อง ใช้ระดับ `Info` สำหรับพารามิเตอร์และขั้นตอนการทำงาน (เริ่มต้น, สำเร็จ/สิ้นสุด) และใช้ระดับ `Error` สำหรับ Exception ทุกฟังก์ชันต้องมีจุดบันทึก Log 'Start', 'End' และ 'Error' สำหรับ handler ให้ใช้ชื่อคลาสหรือ handler ในข้อความ Log และให้บันทึกพารามิเตอร์ของ SQL ก่อนการประมวลผล"", '**บันทึก Log คำสั่ง SQL:** นอกเหนือจากการบันทึก Log การทำงานปกติ ให้บันทึกสตริงคำสั่ง SQL ฉบับเต็มก่อนที่จะสั่งประมวลผลเสมอ โดยใช้ logger ระดับ info ในรูปแบบที่ชัดเจน เช่น `_logger.LogInformation(""[MethodName] SQL => {SqlQuery}"", sql.ToString());` เพื่อให้การแก้ไขข้อบกพร่องง่ายขึ้น']",ในการบันทึก Log ของฟังก์ชัน ควรเริ่มต้นด้วยการบันทึก Log เมื่อฟังก์ชันเริ่มต้นทำงาน ('Start') โดยใช้ระดับ Info เพื่อระบุว่าฟังก์ชันเริ่มทำงานแล้ว และอาจรวมถึงพารามิเตอร์ที่ฟังก์ชันได้รับ จากนั้นเมื่อฟังก์ชันทำงานเสร็จสิ้น ควรบันทึก Log อีกครั้ง ('End') โดยใช้ระดับ Info เพื่อระบุว่าฟังก์ชันทำงานเสร็จสมบูรณ์ หากเกิดข้อผิดพลาด (Exception) ในระหว่างการทำงานของฟังก์ชัน ควรบันทึก Log โดยใช้ระดับ Error เพื่อระบุว่าเกิดข้อผิดพลาดขึ้นและให้ข้อมูลเกี่ยวกับข้อผิดพลาดนั้น การบันทึก Log คำสั่ง SQL ก่อนประมวลผลก็เป็นสิ่งสำคัญเพื่อช่วยในการแก้ไขข้อบกพร่อง,"ใน 1 ฟังก์ชันต้องมี logger 3 ที่. เริ่มจาก Logger Start ที่ส่วนแรกใน try block, Logger End ก่อนบรรทัด return, และ Logger Error ใน catch block. ข้อความใน log ควรมีชื่อฟังก์ชัน, สถานะ (Start/End/Error), รายละเอียดการทำงาน, และชื่อ Module.",,,
การตรวจสอบฟิลด์ที่จำเป็น (Require Field) ใน Backend มีความสำคัญอย่างไร ทั้งๆ ที่ Frontend มีการดักจับอยู่แล้ว,['**ตรวจสอบฟิลด์ที่จำเป็นที่ Backend:** ก่อนบันทึกข้อมูล ให้ตรวจสอบฟิลด์ที่จำเป็นที่ฝั่ง Backend เสมอเพื่อให้แน่ใจว่าไม่ใช่ค่าว่างหรือไม่มีข้อมูล แม้ว่า Frontend จะมีการตรวจสอบอยู่แล้วก็ตาม นี่เป็นชั้นความปลอดภัยที่สำคัญเพื่อป้องกันการยิง request ตรงมาที่ API (เช่น จาก Postman) หากฟิลด์ที่จำเป็นขาดหายไปให้โยน Exception'],แม้ว่า Frontend จะมีการตรวจสอบฟิลด์ที่จำเป็นแล้ว แต่การตรวจสอบที่ Backend ยังคงมีความสำคัญเนื่องจากเป็นชั้นความปลอดภัยเพิ่มเติมที่ป้องกันการยิง request ตรงมาที่ API โดยไม่ผ่าน Frontend (เช่น จาก Postman) หากฟิลด์ที่จำเป็นขาดหายไป Backend ควรโยน Exception เพื่อแจ้งให้ทราบถึงข้อผิดพลาด,สำคัญ เพราะอาจมีกรณีที่ผู้ใช้ยิง request ผ่านเครื่องมืออย่าง Postman ซึ่งจะไม่ผ่านการตรวจสอบของ Frontend.,,,
เปรียบเทียบวิธีการเขียน SQL Statement สองแบบที่แนะนำและไม่แนะนำ พร้อมอธิบายเหตุผล,"['**การจัดรูปแบบคำสั่ง SQL:** จัดรูปแบบคำสั่ง SQL ที่ซับซ้อนใน `StringBuilder` โดยใช้สตริงหลายบรรทัด (เช่น `sql.Append(@""SELECT ... FROM ..."")`) แทนการเรียก `AppendLine()` หลายๆ ครั้ง วิธีนี้ทำให้สามารถคัดลอกคำสั่ง SQL ไปทดสอบในโปรแกรมจัดการฐานข้อมูลได้ง่ายขึ้น']","กฎ BE-11 แนะนำให้จัดรูปแบบคำสั่ง SQL ที่ซับซ้อนใน `StringBuilder` โดยใช้สตริงหลายบรรทัด (เช่น `sql.Append(@""SELECT ... FROM ..."")`) แทนการเรียก `AppendLine()` หลายๆ ครั้ง เหตุผลคือวิธีนี้ทำให้สามารถคัดลอกคำสั่ง SQL ไปทดสอบในโปรแกรมจัดการฐานข้อมูลได้ง่ายขึ้น ซึ่งช่วยในการแก้ไขและตรวจสอบความถูกต้องของคำสั่ง SQL ได้อย่างมีประสิทธิภาพ","แบบที่ไม่แนะนำคือการใช้ `sql.AppendLine` ในแต่ละบรรทัด เพราะจะคัดลอกไปทดลองใน DBeaver ได้ลำบาก. แบบที่แนะนำคือการเขียน SQL เป็นบล็อกเดียวโดยใช้ `sql.Append(@""..."")` ซึ่งทำให้คัดลอกไปใช้งานได้ง่ายกว่า.",,,
การตรวจสอบค่า Null ของฟิลด์กับการตรวจสอบค่าว่าง (Whitespace) ใน Backend มีความแตกต่างกันอย่างไร และควรจัดการอย่างไร,"['**ตรวจสอบฟิลด์ที่จำเป็นที่ Backend:** ก่อนบันทึกข้อมูล ให้ตรวจสอบฟิลด์ที่จำเป็นที่ฝั่ง Backend เสมอเพื่อให้แน่ใจว่าไม่ใช่ค่าว่างหรือไม่มีข้อมูล แม้ว่า Frontend จะมีการตรวจสอบอยู่แล้วก็ตาม นี่เป็นชั้นความปลอดภัยที่สำคัญเพื่อป้องกันการยิง request ตรงมาที่ API (เช่น จาก Postman) หากฟิลด์ที่จำเป็นขาดหายไปให้โยน Exception', '**ตรวจสอบความยาวของฟิลด์:** กำหนดข้อจำกัดความยาวของฟิลด์ใน Domain Entity โดยใช้ attribute `[MaxLength(value)]` ให้ตรงกับสคีมาของฐานข้อมูล แม้วิธีนี้จะป้องกันข้อมูลที่ยาวเกินไปได้ แต่ไม่สามารถป้องกันสตริงที่เป็นช่องว่างอย่างเดียวได้ สำหรับฟิลด์ที่ไม่อนุญาตให้มีค่าเป็นช่องว่าง ให้เพิ่มการตรวจสอบสตริงเพิ่มเติม', '**ตรวจสอบอาร์เรย์ก่อนใช้งาน:** ก่อนที่จะวนลูปในคอลเลกชันหรืออาร์เรย์ด้วย `foreach` ให้ตรวจสอบก่อนเสมอว่าข้อมูลนั้นไม่ใช่ `null` และมีสมาชิกอยู่ (เช่น `if (items != null && items.Any())`) การตรวจสอบง่ายๆ นี้จะช่วยป้องกันการเกิด `NullReferenceException` เมื่อคอลเลกชันว่างเปล่า', '**ตรวจสอบอ็อบเจกต์ Null ก่อนเข้าถึง Property:** เมื่อทำงานกับอ็อบเจกต์ที่อาจเป็น `null` (เช่น entity ที่ดึงจากฐานข้อมูล) ให้ใช้ null-conditional operator (`?.`) เพื่อเข้าถึง property อย่างปลอดภัยและป้องกันการเกิด `NullReferenceException` ตัวอย่างเช่น ใช้ `if (emp?.MainDept != null)` ก่อนที่จะใช้ property นั้น']",การตรวจสอบค่า Null ใน Backend มีความสำคัญเพื่อป้องกันข้อผิดพลาด `NullReferenceException` เมื่อพยายามเข้าถึง property หรือ method ของอ็อบเจกต์ที่ไม่มีอยู่จริง ในขณะที่การตรวจสอบค่าว่าง (Whitespace) มีความสำคัญเมื่อต้องการให้แน่ใจว่าฟิลด์ข้อความไม่ได้มีเพียงช่องว่าง ซึ่งอาจทำให้เกิดปัญหาในการประมวลผลข้อมูล การจัดการที่เหมาะสมคือการใช้การตรวจสอบทั้งสองประเภท โดยตรวจสอบค่า Null ก่อนเสมอ และหากเป็นฟิลด์ข้อความที่ไม่อนุญาตให้มีค่าว่าง ให้ตรวจสอบเพิ่มเติมว่าสตริงนั้นไม่ได้มีเพียงช่องว่าง,การใช้ `[Required]` ใน Entity จะดักจับได้เพียงค่า `null` แต่ไม่ดักจับค่าว่าง. หากต้องการดักจับช่องว่างด้วย ต้องเขียนโค้ดเพิ่มเติมเองโดยใช้ `string.IsNullOrWhiteSpace()`.,,,
มีการระบุถึงการใช้ SaveChangesAsync โดยไม่ใช้ AddRangeAsync หรือไม่,"['**ใช้ AddRange สำหรับการเพิ่มข้อมูลจำนวนมาก:** เมื่อต้องการเพิ่มข้อมูลหลายรายการที่ตรงกับ Entity ให้วนลูปข้อมูลต้นทางเพื่อสร้างอ็อบเจกต์ Entity ใหม่ แล้วเพิ่มลงใน `List<>` จากนั้นใช้ `_context.Set<>().AddRangeAsync()` เพื่อเพิ่มข้อมูลทั้งหมดลงในฐานข้อมูลอย่างมีประสิทธิภาพในครั้งเดียว วิธีนี้ใช้สำหรับการเพิ่มข้อมูลใหม่เท่านั้น ไม่สามารถใช้กับการอัปเดตได้', '**ตรวจสอบฟิลด์ที่จำเป็นที่ Backend:** ก่อนบันทึกข้อมูล ให้ตรวจสอบฟิลด์ที่จำเป็นที่ฝั่ง Backend เสมอเพื่อให้แน่ใจว่าไม่ใช่ค่าว่างหรือไม่มีข้อมูล แม้ว่า Frontend จะมีการตรวจสอบอยู่แล้วก็ตาม นี่เป็นชั้นความปลอดภัยที่สำคัญเพื่อป้องกันการยิง request ตรงมาที่ API (เช่น จาก Postman) หากฟิลด์ที่จำเป็นขาดหายไปให้โยน Exception']",ไม่มีกฎใดในรายการที่ให้มาที่กล่าวถึงการใช้ `SaveChangesAsync` โดยไม่ใช้ `AddRangeAsync` โดยตรง อย่างไรก็ตาม กฎ BE-2 แนะนำให้ใช้ `AddRangeAsync` สำหรับการเพิ่มข้อมูลจำนวนมากเพื่อประสิทธิภาพ และกฎ BE-5 เน้นย้ำถึงความสำคัญของการตรวจสอบฟิลด์ที่จำเป็นที่ฝั่ง Backend ก่อนบันทึกข้อมูล ซึ่งอาจเกี่ยวข้องกับการตัดสินใจว่าจะใช้ `AddRangeAsync` หรือไม่,ในเอกสารมีการกล่าวถึง `_context.SaveChangesAsync(cancellationToken)` หลังจากใช้ `_context.Set<>().AddRangeAsync()`. แต่ไม่ได้อธิบายถึงการใช้ `SaveChangesAsync` โดยตรงในกรณีอื่นๆ.,,,
ทุก Component ควรจะ extends จากคลาสใด และต้องทำอะไรใน constructor,['**การ Implement Component Lifecycle:** ทุก component จะต้อง `extends` คลาส `SubscriptionDisposer` และเรียก `super()` ใน `constructor` หากมีการใช้งาน `ngOnInit` คลาสจะต้อง `implements OnInit` ด้วย และเมื่อทำการ `override ngOnDestroy` ให้จัดการล้างค่าต่างๆ ที่จำเป็นและต้องมั่นใจว่า `super.ngOnDestroy()` ถูกเรียกเป็นคำสั่งสุดท้ายในเมธอดเสมอ'],ตามมาตรฐาน FE-2 ทุก component จะต้อง `extends` คลาส `SubscriptionDisposer` และเรียก `super()` ใน `constructor` หากมีการใช้งาน `ngOnInit` คลาสจะต้อง `implements OnInit` ด้วย และเมื่อทำการ `override ngOnDestroy` ให้จัดการล้างค่าต่างๆ ที่จำเป็นและต้องมั่นใจว่า `super.ngOnDestroy()` ถูกเรียกเป็นคำสั่งสุดท้ายในเมธอดเสมอ,ทุก Component ต้อง `extends SubscriptionDisposer` และต้องเรียก `super()` ภายใน `constructor`.,,,
เมื่อต้องการทำงานบางอย่างตอนออกจาก Component ควรเขียนโค้ดที่ไหน และมีเงื่อนไขสำคัญอะไรที่ต้องทำเสมอ,['**การ Implement Component Lifecycle:** ทุก component จะต้อง `extends` คลาส `SubscriptionDisposer` และเรียก `super()` ใน `constructor` หากมีการใช้งาน `ngOnInit` คลาสจะต้อง `implements OnInit` ด้วย และเมื่อทำการ `override ngOnDestroy` ให้จัดการล้างค่าต่างๆ ที่จำเป็นและต้องมั่นใจว่า `super.ngOnDestroy()` ถูกเรียกเป็นคำสั่งสุดท้ายในเมธอดเสมอ'],เมื่อต้องการทำงานบางอย่างเมื่อออกจาก Component ควรใช้ `ngOnDestroy` ซึ่งเป็นส่วนหนึ่งของ Component Lifecycle ใน Angular สิ่งสำคัญคือ Component จะต้อง `extends` คลาส `SubscriptionDisposer` และเรียก `super()` ใน `constructor` หากมีการใช้งาน `ngOnInit` คลาสจะต้อง `implements OnInit` ด้วย และเมื่อทำการ `override ngOnDestroy` ให้จัดการล้างค่าต่างๆ ที่จำเป็นและต้องมั่นใจว่า `super.ngOnDestroy()` ถูกเรียกเป็นคำสั่งสุดท้ายในเมธอดเสมอ เพื่อให้แน่ใจว่าการจัดการ Subscription และการล้างข้อมูลอื่นๆ ที่เกี่ยวข้องกับ `SubscriptionDisposer` ทำงานอย่างถูกต้อง,ควรเขียนโค้ดที่ต้องการใน `ngOnDestroy()` และต้องเรียก `super.ngOnDestroy()` ที่บรรทัดสุดท้ายเสมอ.,,,
หากต้องการใช้ DatePipe ต้องกำหนดค่าที่ใดบ้าง,"['**ใช้ DatePipe สำหรับการจัดรูปแบบวันที่:** สำหรับงานจัดรูปแบบวันที่ทั้งหมด ให้ใช้ `DatePipe` ที่มากับ Angular โดยเพิ่มเข้าไปใน `providers` ของ component, inject เข้าไปใน `constructor` จากนั้นเรียกใช้ `this.datePipe.transform()` เพื่อจัดรูปแบบค่าวันที่อย่างสอดคล้องกัน']",ในการใช้ `DatePipe` สำหรับการจัดรูปแบบวันที่ใน Angular คุณต้องเพิ่ม `DatePipe` เข้าไปในส่วน `providers` ของ component ที่คุณต้องการใช้งาน จากนั้น inject `DatePipe` เข้าไปใน `constructor` ของ component นั้น และสุดท้ายเรียกใช้ `this.datePipe.transform()` เพื่อจัดรูปแบบค่าวันที่ตามที่คุณต้องการ วิธีนี้จะช่วยให้การจัดรูปแบบวันที่ในแอปพลิเคชันของคุณมีความสอดคล้องกัน,ต้องระบุ `DatePipe` ใน `providers` ของ `@Component` และประกาศ (inject) ใน `constructor`.,,,
เพราะเหตุใดจึงไม่ควรเขียน Style ในไฟล์ HTML โดยตรง,['**ใช้ Stylesheet ภายนอกเท่านั้น:** หลีกเลี่ยงการใช้ attribute `style` และแท็ก `<style>` ในไฟล์ HTML การจัดสไตล์ CSS ทั้งหมดต้องถูกกำหนดในไฟล์ `.scss` หรือ `.css` ภายนอก เพื่อแยกส่วนของโค้ดให้ชัดเจนและเพิ่มความสะดวกในการบำรุงรักษา'],การเขียนสไตล์ในไฟล์ HTML โดยตรงผ่าน attribute `style` หรือแท็ก `<style>` ทำให้โค้ด HTML ปะปนกับโค้ด CSS ซึ่งส่งผลให้โค้ดอ่านยากและแก้ไขยาก การแยกส่วนการทำงาน (separation of concerns) เป็นหลักการสำคัญในการพัฒนาซอฟต์แวร์ การกำหนดสไตล์ CSS ทั้งหมดในไฟล์ `.scss` หรือ `.css` ภายนอกช่วยให้โค้ดเป็นระเบียบ ง่ายต่อการบำรุงรักษา และสามารถนำสไตล์กลับมาใช้ใหม่ได้ง่ายขึ้น นอกจากนี้ การใช้ stylesheet ภายนอกยังช่วยให้การปรับเปลี่ยนสไตล์ทำได้ง่ายและมีประสิทธิภาพมากขึ้น,ไม่ควรเขียนสไตล์โดยตรงใน HTML แต่ควรใช้ไฟล์สไตล์ภายนอกแทน.,,,
"แทนที่จะใช้ <input>, <textarea>, และ <input type=""number""> ควรใช้ Component ใดแทน","['**อย่าเขียนโค้ดซ้ำซ้อน (DRY):** หลีกเลี่ยงการเขียนโค้ดซ้ำโดยการสร้าง component, service, และฟังก์ชันอรรถประโยชน์ที่สามารถนำกลับมาใช้ใหม่ได้ สำหรับองค์ประกอบ UI ทั่วไป ให้ใช้ custom component ที่สร้างไว้แล้ว เช่น `<textbox>`, `<areabox>`, หรือ `<number>` แทนแท็ก input ของ HTML ดั้งเดิม เพื่อให้มั่นใจได้ถึงการทำงานและสไตล์ที่สอดคล้องกัน']","กฎ FE-12 แนะนำให้หลีกเลี่ยงการเขียนโค้ดซ้ำซ้อน (DRY) โดยการสร้าง component ที่สามารถนำกลับมาใช้ใหม่ได้ สำหรับองค์ประกอบ UI ทั่วไป เช่น input, textarea, และ input type=""number"" ควรใช้ custom component ที่สร้างไว้แล้ว เช่น `<textbox>`, `<areabox>`, หรือ `<number>` แทนแท็ก input ของ HTML ดั้งเดิม เพื่อให้มั่นใจได้ถึงการทำงานและสไตล์ที่สอดคล้องกัน การใช้ custom component ช่วยให้ง่ายต่อการบำรุงรักษาและปรับปรุงในอนาคต","ควรใช้ `<textbox>` แทน `<input>` , `<areabox>` แทน `<textarea>` , และ `<number>` แทน `<input type=""number"">`.",,,
"อธิบายหลักการทำงานของ ""หน้าเพิ่ม"" และ ""หน้ารายละเอียด"" โดยใช้ Component เดียวกัน ทำได้อย่างไร",['**การตั้งชื่อและการใช้ซ้ำ Component:** ตั้งชื่อ component ตามเอกสาร functional spec สำหรับหน้าที่มีมุมมองการเพิ่มและดูรายละเอียดที่ใช้ร่วมกัน ให้สร้างเป็น detail component เพียงไฟล์เดียว (เช่น `feature-detail.component.ts`) แล้วใช้แฟล็กประเภท boolean อย่าง `isEdit` เพื่อสลับสถานะของ UI แทนที่จะสร้าง component แยกกันสำหรับแต่ละโหมด'],"หลักการทำงานของ ""หน้าเพิ่ม"" และ ""หน้ารายละเอียด"" โดยใช้ Component เดียวกันนั้น อ้างอิงตามกฎ FE-1 ซึ่งแนะนำให้ตั้งชื่อ Component ตามเอกสาร functional spec และสำหรับหน้าที่มีมุมมองการเพิ่มและดูรายละเอียดที่ใช้ร่วมกัน ให้สร้างเป็น detail component เพียงไฟล์เดียว (เช่น `feature-detail.component.ts`) แล้วใช้แฟล็กประเภท boolean อย่าง `isEdit` เพื่อสลับสถานะของ UI แทนที่จะสร้าง Component แยกกันสำหรับแต่ละโหมด วิธีนี้ช่วยลดความซ้ำซ้อนของโค้ดและทำให้การบำรุงรักษาง่ายขึ้น",สามารถทำได้โดยการใช้ Component เดียว (เช่น orms04-detail) แล้วตรวจสอบว่ามีข้อมูล id หรือ code ส่งมาหรือไม่. หากมีข้อมูล ให้ตั้งค่าตัวแปร `this.edit = true`  แล้วใช้ `*ngIf` ใน HTML เพื่อควบคุมการแสดงผลของปุ่มหรือฟอร์มตามโหมดนั้นๆ.,,,
การจัดการวันที่และเวลาใน Frontend มีหลักการสำคัญอย่างไร และทำไมจึงต้องทำเช่นนั้น,"['**ใช้วันที่และเวลาจากฝั่ง Server:** ห้ามสร้าง `new Date()` โดยตรงที่ฝั่ง Frontend เพราะจะเป็นการใช้เวลาของเครื่อง Client ให้ inject `DatetimeService` เพื่อดึงเวลาปัจจุบันที่ถูกต้องจาก Server ผ่าน API แทน เพื่อให้แน่ใจว่าเวลามีความสอดคล้องกันสำหรับผู้ใช้ทุกคน', '**ใช้ DatePipe สำหรับการจัดรูปแบบวันที่:** สำหรับงานจัดรูปแบบวันที่ทั้งหมด ให้ใช้ `DatePipe` ที่มากับ Angular โดยเพิ่มเข้าไปใน `providers` ของ component, inject เข้าไปใน `constructor` จากนั้นเรียกใช้ `this.datePipe.transform()` เพื่อจัดรูปแบบค่าวันที่อย่างสอดคล้องกัน']",การจัดการวันที่และเวลาใน Frontend มีความสำคัญอย่างยิ่งต่อความถูกต้องและความสอดคล้องของข้อมูลที่แสดงให้ผู้ใช้เห็น หลักการสำคัญคือการหลีกเลี่ยงการใช้ `new Date()` โดยตรงที่ Frontend เนื่องจากจะเป็นการใช้เวลาของเครื่อง Client ซึ่งอาจแตกต่างกันไปในแต่ละผู้ใช้ ดังนั้นจึงควรใช้ `DatetimeService` เพื่อดึงเวลาปัจจุบันที่ถูกต้องจาก Server ผ่าน API แทน นอกจากนี้ สำหรับการจัดรูปแบบวันที่ ควรใช้ `DatePipe` ที่มากับ Angular เพื่อให้การจัดรูปแบบวันที่เป็นไปอย่างสอดคล้องกันทั่วทั้งแอปพลิเคชัน การทำเช่นนี้จะช่วยให้มั่นใจได้ว่าข้อมูลวันที่และเวลาที่แสดงให้ผู้ใช้เห็นมีความถูกต้องและสอดคล้องกัน ไม่ว่าผู้ใช้จะอยู่ที่ใดก็ตาม,หลักการสำคัญคือไม่ควร `new Date()` ด้วยตัวเอง แต่ให้ยิง API ไปขอเวลาจาก Backend ก่อน แล้วจึงนำค่าที่ได้มาสร้างเป็นอ็อบเจ็กต์ Date. ทำเช่นนี้เพื่อให้แน่ใจว่าเวลาที่ใช้เป็นเวลามาตรฐานจากเซิร์ฟเวอร์ ไม่ใช่เวลาจากเครื่องของผู้ใช้ซึ่งอาจไม่ตรงกัน.,,,
การลดโค้ดที่ซ้ำซ้อนใน Frontend มีแนวทางปฏิบัติอย่างไรบ้าง ยกตัวอย่างประกอบ,"['**อย่าเขียนโค้ดซ้ำซ้อน (DRY):** หลีกเลี่ยงการเขียนโค้ดซ้ำโดยการสร้าง component, service, และฟังก์ชันอรรถประโยชน์ที่สามารถนำกลับมาใช้ใหม่ได้ สำหรับองค์ประกอบ UI ทั่วไป ให้ใช้ custom component ที่สร้างไว้แล้ว เช่น `<textbox>`, `<areabox>`, หรือ `<number>` แทนแท็ก input ของ HTML ดั้งเดิม เพื่อให้มั่นใจได้ถึงการทำงานและสไตล์ที่สอดคล้องกัน']","การลดโค้ดที่ซ้ำซ้อนใน Frontend สามารถทำได้โดยการสร้าง component, service, และฟังก์ชันอรรถประโยชน์ที่สามารถนำกลับมาใช้ใหม่ได้ ตัวอย่างเช่น สำหรับองค์ประกอบ UI ทั่วไป เช่น textbox, areabox, หรือ number ควรใช้ custom component ที่สร้างไว้แล้ว แทนแท็ก input ของ HTML ดั้งเดิม เพื่อให้มั่นใจได้ถึงการทำงานและสไตล์ที่สอดคล้องกัน ซึ่งจะช่วยลดความซ้ำซ้อนและเพิ่มความสามารถในการบำรุงรักษาโค้ด",ควรแยกฟังก์ชันการทำงานที่ใช้บ่อยออกมาเป็น method กลางเพื่อเรียกใช้ซ้ำ เช่น การสร้าง method `Download(blob)`. นอกจากนี้ยังควรใช้ component ที่มีอยู่แล้วซ้ำ เช่น ใช้ `<textbox>` แทน `<input>`  และใช้ฟังก์ชัน utility ที่มีอยู่แล้ว เช่น `isEmpty` แทนที่จะเขียนโค้ดตรวจสอบเอง.,,,
เปรียบเทียบวิธีการทำ Comparation operation ในไฟล์ HTML ที่ผิดและที่ถูก,"['**ห้ามเขียน Logic ในไฟล์ HTML:** ห้ามทำการเปรียบเทียบหรือใช้ ternary operator โดยตรงใน template ของ HTML แต่ให้สร้างเป็นเมธอดใน component แล้วเรียกใช้จาก template แทน เช่น เปลี่ยนจาก `*ngIf=""item.status === \'Y\'""` เป็น `*ngIf=""isActive(item)""` เพื่อให้ template สะอาดและสามารถทดสอบ Logic ได้']",การเขียน Logic โดยตรงในไฟล์ HTML เช่น การเปรียบเทียบหรือใช้ ternary operator ทำให้ template ไม่สะอาดและทดสอบ Logic ได้ยาก ดังนั้นควรสร้างเป็นเมธอดใน component แล้วเรียกใช้จาก template แทน เพื่อให้ template สะอาดและสามารถทดสอบ Logic ได้ง่ายขึ้น,"วิธีที่ผิดคือการเขียนเงื่อนไขเปรียบเทียบโดยตรงใน HTML เช่น `*ngIf=""checked == 'Y' ? true : false""`. วิธีที่ถูกคือการสร้างฟังก์ชันในไฟล์ .ts (เช่น `isChecked(checked)`) แล้วเรียกใช้จาก HTML: `*ngIf=""isChecked(checked)""`.",,,
เปรียบเทียบวิธีการแปลภาษาในไฟล์ .html และ .ts พร้อมยกตัวอย่าง,"[""**ใช้ Translation Key สำหรับข้อความที่แสดงผลทั้งหมด:** ห้ามฮาร์ดโค้ดข้อความใดๆ ที่ผู้ใช้มองเห็น แต่ให้ใช้ translation key ร่วมกับ `translate` pipe ใน HTML (เช่น `{{ 'label.MyLabel' | translate }}`) หรือผ่าน message service ใน TypeScript (เช่น `this.ms.warning('message.MyMessage')`) เพื่อรองรับการแปลภาษา""]",กฎ FE-15 กำหนดให้ใช้ translation key ร่วมกับ `translate` pipe ใน HTML (เช่น `{{ 'label.MyLabel' | translate }}`) หรือผ่าน message service ใน TypeScript (เช่น `this.ms.warning('message.MyMessage')`) แทนการฮาร์ดโค้ดข้อความใดๆ ที่ผู้ใช้มองเห็น เพื่อให้รองรับการแปลภาษาได้ง่ายและมีประสิทธิภาพ,"ในไฟล์ `.html` จะใช้ pipe `translate` เช่น `{{ ""label.RDMS01.DefineDecoration"" | translate }}`. ในไฟล์ `.ts` จะใช้สำหรับแสดงข้อความแจ้งเตือน โดยเรียกผ่าน Service เช่น `this.ms.warning(""message.PleaseFillSaving"")`.",,,
มีการอธิบายถึงวิธีการจัดการ State Management เช่น NgRx หรือไม่,[],ไม่มีกฎใดในรายการที่ให้มาที่กล่าวถึงวิธีการจัดการ State Management เช่น NgRx หรือเทคนิคอื่น ๆ ที่เกี่ยวข้องกับการจัดการสถานะของแอปพลิเคชัน,ไม่มี ในเอกสารที่ให้มาไม่ได้มีการกล่าวถึงการใช้เครื่องมือ State Management เช่น NgRx.,,,
